defpackage firrtl/verilog :
   import core
   import verse
   import firrtl/ir-utils
   import firrtl/ir2

public defstruct RemoveSeqMem <: Pass
public defmethod pass (b:RemoveSeqMem) -> (Circuit -> Circuit) : remove-smem{_}
public defmethod name (b:RemoveSeqMem) -> String : "Remove SeqMem"
public defmethod short-name (b:RemoveSeqMem) -> String : "remove-smem"


;============ Utilz =============

;============ Remove Seq Mem =============

defn remove-smem (m:InModule) -> InModule :
   val hash = get-sym-hash(m)
   val smems = Vector<Symbol>()
   defn remove-smem-s (s:Stmt) -> Stmt :
      map{remove-smem-s,_} $ match(s) :
         (s:DefMemory) : 
            if seq?(s) : add(smems,name(s))
            DefMemory(info(s),name(s),type(s),false)
         (s:DefAccessor) : 
            if dir(s) == WRITE and contains?(smems, name(source(s) as Ref)) :
               val regged-index = firrtl-gensym(name(index(s) as Ref),hash)
               val ref = Ref(regged-index,type(index(s)))
               Begin $ to-list $ 
                 [ DefRegister(info(s),regged-index,type(index(s)))
                   Connect(ref,index(s))
                   DefAccessor(info(s),dir(s),name(s),source(s),ref) ]
            else : s
         (s) : s

   InModule(info(m),name(m),ports(m),remove-smem-s(body(m),hash))

public defn remove-smem (c:Circuit) -> Circuit :
   for m in modules(c) do :
      match(m) :
         (m:InModule) : remove-smem(m)
         (m:ExModule) : m

;============ VERILOG ==============

public defstruct Verilog <: Pass :
   file : String
public defmethod pass (b:Verilog) -> (Circuit -> Circuit) : emit-verilog{file(b),_}
public defmethod name (b:Verilog) -> String : "To Verilog"
public defmethod short-name (b:Verilog) -> String : "To Verilog"

defstruct DecAndConnect :
   dec : Stmt
   con : Connect

;============ Utilz =============
defn width! (w:Width) -> Int :
   match(w) : 
      (w:IntWidth) : width(w)
      (w) : error("Non-supported width type.")

defn width! (t:Type) -> Int :
   match(t) :
      (t:UIntType) : width!(width(t))
      (t:SIntType) : width!(width(t))
      (t) : error("Non-supported type.")

defn emit (w:Width) -> String :
   match(w) : 
      (w:IntWidth) : 
         if width(w) >= 1 : string-join $ ["[" width(w) - 1 ":0]"] ;TODO check if need to special case 0 or 1 width wires
         else : ""

      (w) : error("Non-supported width type.")

defn get-width (t:Type) -> String :
   match(t) :
      (t:UIntType) : emit(width(t))
      (t:SIntType) : emit(width(t))
      (t) : error("Non-supported type.")

defn remove-subfield (e:Expression) -> Expression :
   match(map(remove-subfield,e)) :
      (e:Subfield) : Ref(to-symbol $ string-join $ [emit(exp(e)) "_" name(e)],type(e))
      (e) : e

;============ Verilog Backend =============

defn emit-as-type (e:Expression,t:Type) -> String : 
   match(t) :
      (t:UIntType) : emit(e)
      (t:SIntType) : string-join(["$signed(" emit(e) ")"])

defn emit-signed-if-any (e:Expression,ls:List<Expression>) -> String : 
   var signed? = false
   for x in ls do :
      if type(x) typeof SIntType : signed? = true
   if not signed? : emit(e)
   else : string-join(["$signed(" emit(e) ")"])

defn emit (e:Expression) -> String :
   match(e) :
      (e:Ref) : to-string $ name(e)
      (e:UIntValue) : string-join $ [width!(type(e)) "'d" value(e)]
      (e:SIntValue) : string-join $ [width!(type(e)) "'sd" value(e)]
      (e:Subfield) : error("Non-supported expression")
      (e:Index) : error("Non-supported expression")
      (e:Register) : error("Non-supported expression")
      (e:ReadPort) : error("Non-supported expression")
      (e:WritePort) : error("Non-supported expression")
      (e:DoPrim) : 
         val sargs = map(emit-as-type{_,type(e)},args(e))
         val xargs = map(emit-signed-if-any{_,args(e)},args(e))
         string-join $ switch {_ == op(e)} :
            ADD-OP : [sargs[0] " + " sargs[1]]
            SUB-OP : [sargs[0] " - " sargs[1]]
            MUL-OP : [sargs[0] " * " sargs[1] ]
            DIV-OP : [sargs[0] " / " sargs[1] ]
            MOD-OP : [sargs[0] " % " sargs[1] ]
            QUO-OP : [sargs[0] " / " sargs[1] ]
            REM-OP : [sargs[0] " % " sargs[1] ]
            ADD-WRAP-OP : [sargs[0], " + " sargs[1]]
            SUB-WRAP-OP : [sargs[0], " - " sargs[1]]
            LESS-OP : [xargs[0] " < " xargs[1]]
            LESS-EQ-OP : [xargs[0] " <= " xargs[1]]
            GREATER-OP : [xargs[0] " > " xargs[1]]
            GREATER-EQ-OP : [xargs[0] " >= " xargs[1]]
            NEQUAL-OP : [xargs[0] " != " xargs[1]]
            EQUAL-OP : [xargs[0] " == " xargs[1]]
            MUX-OP : [emit(args(e)[0]) " ? " sargs[1] " : " sargs[2]]
            PAD-OP : 
               val x = args(e)[0]
               val w = width!(type(x))
               val diff = consts(e)[0] - w
               if w == 0 : [ emit(x) ]
               else : 
                  if type(e) typeof SIntType : ["{{" diff "{" emit(x) "[" w - 1 "]}}, " emit(x) " }"]
                  else : ["{{" diff "'d0 }, " emit(x) " }"]
            AS-UINT-OP : 
               ["$unsigned(" emit(args(e)[0]) ")"]
            AS-SINT-OP : 
               ["$signed(" emit(args(e)[0]) ")"]
            DYN-SHIFT-LEFT-OP : [sargs[0] " << " emit(args(e)[1])]
            DYN-SHIFT-RIGHT-OP : 
               if type(e) typeof SIntType : [sargs[0] " >>> " emit(args(e)[1])]
               else : [sargs[0] " >> " emit(args(e)[1])]
            SHIFT-LEFT-OP : [sargs[0] " << " consts(e)[0]]
            SHIFT-RIGHT-OP : 
               if type(e) typeof SIntType : [sargs[0] " >>> " consts(e)[0]]
               else : [sargs[0] " >> " consts(e)[0]]
            NEG-OP : ["-{" sargs[0] "}"]
            CONVERT-OP : 
               match(type(args(e)[0])) :
                  (t:UIntType) : ["{1'b0," sargs[0] "}"]
                  (t:SIntType) : [sargs[0]]
            BIT-NOT-OP : ["!" sargs[0]]
            BIT-AND-OP : [sargs[0] " & " sargs[1]]
            BIT-OR-OP : [sargs[0] " | " sargs[1]]
            BIT-XOR-OP : [sargs[0] " ^ " sargs[1]]
            CONCAT-OP : ["{" sargs[0] "," sargs[1] "}"]
            BIT-SELECT-OP : [sargs[0] "[" consts(e)[0] "]"]
            BITS-SELECT-OP : [sargs[0] "[" consts(e)[0] ":" consts(e)[1] "]"]
            BIT-AND-REDUCE-OP : 
               var v = sargs[0]
               for x in tail(args(e)) do :
                  v = concat(v, [" & " emit(x)])
               v
            BIT-OR-REDUCE-OP : 
               var v = sargs[0]
               for x in tail(args(e)) do :
                  v = concat(v, [" | " emit(x)])
               v
            BIT-XOR-REDUCE-OP : 
               var v = sargs[0]
               for x in tail(args(e)) do :
                  v = concat(v, [" ^ " emit(x)])
               v


defn get-name (e:Expression) -> Symbol :
   match(e) :
      (e:Ref) : name(e)
      (e:Subfield) : symbol-join([get-name(exp(e)) `. name(e))
      (e) : error("Shouldn't be here")

defn emit-module (m:InModule) :
   val decs = HashTable<Symbol,Stmt>(sym-hash) ; all declarations
   val cons = HashTable<Symbol,Stmt>(sym-hash) ; all connections
   defn build-table (m:InModule) :
      defn build-table (s:Stmt) -> Stmt :
         match(map(build-table,map(remove-subfield,s))) : 
            (s:DefWire|DefReg|DefAccessor|DefMemory|DefNode|DefInstance) : decs[name(s)] = s
            (s:Conditionally) : 
               val n = name(loc(conseq(s) as Connect))
               cons[n] = s
            (s:Connect) : 
               val n = get-name(loc(s))
               cons[n] = s
            (s) : false
         s
      build-table(body(m))
   build-table(m)

   val wires = Vector<Streamable>()
   val regs = Vector<Streamable>()
   val inits = Vector<Streamable>()
   val assigns = Vector<Streamable>()
   val updates = Vector<Streamable>()
   val insts = HashTable<Symbol,Symbol>(symbol-hash) ; inst -> module
   val inst-ports = HashTable<Symbol,Vector<Streamable>>(symbol-hash)

   val sh = get-sym-hash(m)

   for dec in decs do :
      match(value(dec)) :
         
   
   defn emit-pred-connect (s:Connect,en:Expression) :
      if blocking?[name(loc(s) as Ref)] :
         add(assigns,["assign " emit(loc(s)) " = " emit(exp(s)) ";"])
      else :
         add(updates,["if(" emit(enable(reg)) ") begin"])
         add(updates,["  " n " <= " emit(value(reg)) ";"])
         add(updates,["end"])


;         add(updates,["if(" en ") begin"])
;         add(updates,["  " emit(mem(wp)) "[" emit(index(wp)) "] <= " emit(exp(s)) ";"])
;         add(updates,["end"])
;      else :
;         if exp(s) typeof Register :
;            val n = name(loc(s) as Ref)
;            val reg = exp(s) as Register
;            add(inits,[n " = {" width!(type(reg)) "{$random}};"])
;            add(updates,["if(" emit(enable(reg)) ") begin"])
;            add(updates,["  " n " <= " emit(value(reg)) ";"])
;            add(updates,["end"])
;         else if exp(s) typeof ReadPort :
;            val n = name(loc(s) as Ref)
;            val rp = exp(s) as ReadPort
;            match(h[name(mem(rp) as Ref)]) :
;               (k:SeqMemKind) : 
;                  val index* = Ref(firrtl-gensym(name(index(rp) as Ref),sh),type(index(rp)))
;                  add(regs,[ "reg  " get-width(type(index*)) " " name(index*) ";"])
;                  add(inits,[name(index*) " = {" width!(type(index*)) "{$random}};"])
;                  add(updates,["if(" emit(enable(rp)) ") begin"])
;                  add(updates,["  " name(index*) " <= " emit(index(rp)) ";"])
;                  add(updates,["end"])
;                  add(assigns,["assign " n " = " emit(mem(rp)) "[" emit(index*) "];"])
;               (k:ComMemKind) : 
;                  add(assigns,["assign " n " = " emit(mem(rp)) "[" emit(index(rp)) "];"])
;         else :
;            add(assigns,["assign " emit(loc(s)) " = " emit(exp(s)) ";"])
      
   defn emit-s (s:Stmt) :
      match(map(remove-subfield,s)) :
         (s:DefWire) : add(wires,["wire " get-width(type(s)) " " name(s) ";"])
         (s:DefRegister) : add(regs,["reg  " get-width(type(s)) " " name(s) ";"])
         (s:DefAccessor) : 
            switch {_ == dir(s)} :
               READ :
                  match(h[name(source(s) as Ref)]) :
                     (k:SeqMemKind) : 
                        val index* = Ref(firrtl-gensym(name(index(rp) as Ref),sh),type(index(rp)))
                        add(regs,[ "reg  " get-width(type(index*)) " " name(index*) ";"])
                        add(inits,[name(index*) " = {" width!(type(index*)) "{$random}};"])
                        add(updates,["if(" emit(enable(rp)) ") begin"])
                        add(updates,["  " name(index*) " <= " emit(index(rp)) ";"])
                        add(updates,["end"])
                        add(assigns,["assign " n " = " emit(mem(rp)) "[" emit(index*) "];"])
                     (k:ComMemKind) : 
                        add(assigns,["assign " n " = " emit(mem(rp)) "[" emit(index(rp)) "];"])
         (s:DefInstance) : 
            inst-ports[name(s)] = Vector<Streamable>()
            insts[name(s)] = name(module(s) as Ref)
            for f in fields(type(module(s)) as BundleType) do :
               val n* = to-symbol $ string-join $ [name(s) "_" name(f)]
               add(wires,["wire " get-width(type(f)) " " n* ";"])
               add(inst-ports[name(s)], ["." name(f) "( " n* " )"])
         (s:DefMemory) :
            val vtype = type(s) as VectorType
            add(regs,["reg  " get-width(type(vtype)) " " name(s) " [0:" size(vtype) "];"])
            add(inits,["for (initvar = 0; initvar < " size(vtype) "; initvar = initvar+1)"])
            add(inits,["  " name(s) "[initvar] = {" width!(type(vtype)) "{$random}};"])
         (s:DefNode) :
            add(wires,["wire " get-width(type(value(s))) " " name(s) ";"])
            add(assigns,["assign " name(s) " = " emit(value(s)) ";"])
         (s:Begin) : do(emit-s, body(s))
         (s:Conditionally) : emit-pred-connect(pred(s),conseq(s) as Connect)
         (s:Connect) : emit-pred-connect(UIntValue(1,1),s)
         (s) : s 
   
   emit-s(body(m))

   ;==== Actually printing module =====
   val port-indent = "    "
   print-all(["module " name(m) "(input clk, input reset,\n"])
   for (p in ports(m),i in 1 to false) do :
      if name(p) !=`reset :
         var end = ",\n"
         if length(ports(m)) - 1 == i :
            end = "\n);\n"
         switch {_ == direction(p)} :
            INPUT  : print-all([port-indent "input  " get-width(type(p)) " " name(p) end])
            OUTPUT : print-all([port-indent "output " get-width(type(p)) " " name(p) end])

   for w in wires do :
      print("  ")
      println-all(w)
   for r in regs do :
      print("  ")
      println-all(r)

   if length(inits) != 0 :
      println("`ifndef SYNTHESIS")
      println("  integer initvar;")
      println("  initial begin")
      println("    #0.002;")
      for i in inits do :
         print-all("    ")
         println-all(i)
      println("  end")
      println("`endif")

   for a in assigns do :
      print("  ")
      println-all(a)

   for x in insts do :
      println-all(["  " value(x) " " key(x) " ("])
      print("       ")
      print-all([".clk( clk )"])
      for (y in inst-ports[key(x)],i in 1 to false) do :
        print(",\n")
        print("       ")
        print-all(y)
        ;if length(inst-ports[key(x)]) != i :
          ;print(",\n")
      println("\n  );")

   if length(updates) != 0 :
      println("  always @(posedge clk) begin")
      for u in updates do :
         print("    ")
         println-all(u)
      println("  end")
   
   println("endmodule")


public defn emit-verilog (file:String, c:Circuit) :
   with-output-file{file, _} $ fn () :
      for m in modules(c) do :
         match(m) :
            (m:InModule) : emit-module(m)
            (m:ExModule) : false

   c
