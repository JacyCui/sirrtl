defpackage firrtl/chirrtl :
   import core
   import verse
   import firrtl/ir2
   import firrtl/ir-utils

public defstruct ToIR <: Pass
public defmethod pass (b:ToIR) -> (Circuit -> Circuit) : to-ir
public defmethod name (b:ToIR) -> String : "To FIRRTL"
public defmethod short-name (b:ToIR) -> String : "to-firrtl"

defstruct MPort :
   name : Symbol
   clk : Expression
defstruct MPorts :
   readers : Vector<MPort>
   writers : Vector<MPort>
   readwriters : Vector<MPort>
defstruct DataRef :
   exp : Expression
   male : Symbol
   female : Symbol
   mask : Symbol

public definterface Gender
public val MALE = new Gender
public val FEMALE = new Gender

defn create-exps (e:Expression) -> List<Expression> :
   match(type(e)) : 
      (t:UIntType|SIntType|ClockType) : list(e)
      (t:BundleType) : 
         for f in fields(t) map-append :
            create-exps(SubField(e,name(f),type(f)))
      (t:VectorType) :
         for i in 0 to size(t) map-append :
            create-exps(SubIndex(e,i,type(t)))

defn to-ir (c:Circuit) :
   defn to-ir-m (m:InModule) -> InModule :
      val hash = HashTable<Symbol,MPorts>(symbol-hash)
      val sh = get-sym-hash(m,keys(v-keywords))
      val repl = HashTable<Symbol,DataRef>(symbol-hash)
      val ut = UnknownType()
      val mport-types = HashTable<Symbol,Type>(symbol-hash)
      defn EMPs () -> MPorts : 
         MPorts(Vector<MPort>(),Vector<MPort>(),Vector<MPort>())
      defn collect-mports (s:Stmt) -> Stmt :
         match(s) :
            (s:CDefMPort) : 
               val mports = get?(hash,mem(s),EMPs())
               switch { _ == direction(s) } :
                  MRead : add(readers(mports),MPort(name(s),exps(s)[1]))
                  MWrite : add(writers(mports),MPort(name(s),exps(s)[1]))
                  MReadWrite : add(readwriters(mports),MPort(name(s),exps(s)[1]))
               hash[mem(s)] = mports
               s
            (s) : map(collect-mports,s)
      defn collect-refs (s:Stmt) -> Stmt :
         match(s) :
            (s:CDefMemory) :
               mport-types[name(s)] = type(s)
               val stmts = Vector<Stmt>()
               val naddr = firrtl-gensym(`GEN,sh)
               val taddr = UIntType(IntWidth(max(1,ceil-log2(size(s)))))
               add(stmts,DefPoison(info(s),naddr,taddr))
               val ndata = firrtl-gensym(`GEN,sh)
               val tdata = type(s)
               add(stmts,DefPoison(info(s),ndata,tdata))
               defn set-poison (vec:List<MPort>,addr:Symbol) -> False :
                  for r in vec do :
                     add(stmts,Connect(info(s),SubField(SubField(Ref(name(s),ut),name(r),ut),addr,taddr),Ref(naddr,taddr)))
                     add(stmts,Connect(info(s),SubField(SubField(Ref(name(s),ut),name(r),ut),`clk,taddr),clk(r)))
               defn set-enable (vec:List<MPort>,en:Symbol) -> False:
                  for r in vec do :
                     add(stmts,Connect(info(s),SubField(SubField(Ref(name(s),ut),name(r),ut),en,taddr),zero))
               defn set-write (vec:List<MPort>,data:Symbol,mask:Symbol) -> False :
                  val tmask = type(create-mask(`blah,type(s)))
                  for r in vec do :
                     add(stmts,Connect(info(s),SubField(SubField(Ref(name(s),ut),name(r),ut),data,tdata),Ref(ndata,tdata)))
                     for x in create-exps(SubField(SubField(Ref(name(s),ut),name(r),ut),mask,tmask)) do :
                        add(stmts,Connect(info(s),x,zero))
                        
               val rds = to-list $ readers $ get?(hash,name(s),EMPs())
               set-poison(rds,`addr)
               set-enable(rds,`en)
               val wrs = to-list $ writers $ get?(hash,name(s),EMPs())
               set-poison(wrs,`addr)
               set-enable(wrs,`en)
               set-write(wrs,`data,`mask)
               val rws = to-list $ readwriters $ get?(hash,name(s),EMPs())
               set-poison(rws,`waddr)
               set-poison(rws,`raddr)
               set-enable(rws,`wen)
               set-enable(rws,`ren)
               set-write(rws,`wdata,`wmask)
               val read-l = 
                  if seq?(s) : 1
                  else : 0
               val mem = DefMemory(info(s),name(s),type(s),size(s),1,read-l,map(name,rds),map(name,wrs),map(name,rws))
               Begin $ List(mem,to-list(stmts))
            (s:CDefMPort) :
               mport-types[name(s)] = mport-types[mem(s)]
               val addrs = Vector<Symbol>()
               val ens = Vector<Symbol>()
               val masks = Vector<Symbol>()
               switch { _ == direction(s) } :
                  MReadWrite : 
                     repl[name(s)] = DataRef(SubField(Ref(mem(s),ut),name(s),ut),`wdata,`rdata,`wmask)
                     add(addrs,`addr)
                     add(ens,`wen)
                     add(ens,`ren)
                     add(masks,`wmask)
                  MWrite :
                     repl[name(s)] = DataRef(SubField(Ref(mem(s),ut),name(s),ut),`data,`data,`mask)
                     add(addrs,`addr)
                     add(ens,`en)
                     add(masks,`mask)
                  else :
                     repl[name(s)] = DataRef(SubField(Ref(mem(s),ut),name(s),ut),`data,`data,`blah)
                     add(addrs,`addr)
                     add(ens,`en)

               val stmts = Vector<Stmt>()
               for x in addrs do :
                  add(stmts,Connect(info(s),SubField(SubField(Ref(mem(s),ut),name(s),ut),x,ut),exps(s)[0]))
               for x in ens do :
                  add(stmts,Connect(info(s),SubField(SubField(Ref(mem(s),ut),name(s),ut),x,ut),one))
               for x in masks do :
                  add(stmts,Connect(info(s),SubField(SubField(Ref(mem(s),ut),name(s),ut),x,ut),exps(s)[2]))
               Begin $ to-list $ stmts   
            (s) : map(collect-refs,s)
      defn to-ir-s (s:Stmt) -> Stmt :
         var has-write-mport? = false
         defn to-ir-e (e:Expression,g:Gender) -> Expression :
            match(map(to-ir-e{_,g},e)) :
               (e:Ref) : 
                  if key?(repl,name(e)) : 
                     val vt = repl[name(e)]
                     switch {g == _ }:
                        MALE : SubField(exp(vt),male(vt),type(e))
                        FEMALE : 
                           has-write-mport? = true
                           SubField(exp(vt),female(vt),type(e))
                  else : e
               (e) : e
         defn get-mask (e:Expression) -> Expression :
            match(map(get-mask,e)) :
               (e:Ref) :
                  if key?(repl,name(e)) : 
                     val vt = repl[name(e)]
                     val f = create-mask(`blah,mport-types[name(e)])
                     SubField(exp(vt),mask(vt),type(f))
                  else : e
               (e) : e
         match(s) :
            (s:Connect) : 
               val stmts = Vector<Stmt>()
               val roc* = to-ir-e(exp(s),MALE)
               val loc* = to-ir-e(loc(s),FEMALE)
               add(stmts,Connect(info(s),loc*,roc*))
               if has-write-mport? :
                  val e = get-mask(loc(s))
                  for x in create-exps(e) do :
                     add(stmts,Connect(info(s),x,UInt(1)))
               if length(stmts > 1) : Begin(to-list(stmts))
               else : stmts[0]
            (s:BulkConnect) : 
               val stmts = Vector<Stmt>()
               val loc* = to-ir-e(loc(s),FEMALE)
               val roc* = to-ir-e(exp(s),MALE)
               add(stmts,BulkConnect(info(s),loc*,roc*))
               if has-write-mport? :
                  val ls = get-valid-points(type(loc(s)),type(exp(s)),DEFAULT,DEFAULT)
                  val locs = create-exps(get-mask(loc(s)))
                  for x in ls do :
                     val loc* = locs[x[0]]
                     add(stmts,Connect(info(s),loc*,UInt(1)))
               if length(stmts > 1) : Begin(to-list(stmts))
               else : stmts[0]
            (s) : map(to-ir-e{_,MALE}, map(to-ir-s,s))
      collect-mports(body(m))
      val s* = collect-refs(body(m))
      InModule(info(m),name(m), ports(m), to-ir-s(s*))
   Circuit(info(c),modules*, main(c)) where :
      val modules* =
         for m in modules(c) map :
            match(m) :
               (m:InModule) : to-ir-m(m)
               (m:ExModule) : m


