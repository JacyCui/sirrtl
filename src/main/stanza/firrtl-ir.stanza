defpackage firrtl/ir2 :
   import core
   import verse
   import bigint2
   
public defmulti info! (x:?) -> FileInfo
public defmethod info! (x:?) : FileInfo()

public val vector-expand-delin = `$
public val bundle-expand-delin = `$
public val module-expand-delin = `$
public val scope-delin = `_
public val inline-delin = `_
public val delin = `_

public definterface Direction
public val INPUT = new Direction
public val OUTPUT = new Direction

public definterface Flip
public val DEFAULT = new Flip
public val REVERSE = new Flip

public definterface Width
public defstruct UnknownWidth <: Width
public defn IntWidth (width:Int) : IntWidth(to-long(width))
public defstruct IntWidth <: Width :
   width: Long

public definterface PrimOp
public val ADD-OP = new PrimOp
public val SUB-OP = new PrimOp
public val MUL-OP = new PrimOp
public val DIV-OP = new PrimOp
public val MOD-OP = new PrimOp
public val QUO-OP = new PrimOp
public val REM-OP = new PrimOp
public val ADD-WRAP-OP = new PrimOp
public val SUB-WRAP-OP = new PrimOp
public val LESS-OP = new PrimOp
public val LESS-EQ-OP = new PrimOp
public val GREATER-OP = new PrimOp
public val GREATER-EQ-OP = new PrimOp
public val NEQUAL-OP = new PrimOp
public val EQUAL-OP = new PrimOp
public val NEQUIV-OP = new PrimOp
public val EQUIV-OP = new PrimOp
;public val MUX-OP = new PrimOp
public val PAD-OP = new PrimOp
public val AS-UINT-OP = new PrimOp
public val AS-SINT-OP = new PrimOp
public val DYN-SHIFT-LEFT-OP = new PrimOp
public val DYN-SHIFT-RIGHT-OP = new PrimOp
public val SHIFT-LEFT-OP = new PrimOp
public val SHIFT-RIGHT-OP = new PrimOp
public val NEG-OP = new PrimOp
public val CONVERT-OP = new PrimOp
public val BIT-NOT-OP = new PrimOp
public val BIT-AND-OP = new PrimOp
public val BIT-OR-OP = new PrimOp
public val BIT-XOR-OP = new PrimOp
public val CONCAT-OP = new PrimOp
public val BIT-SELECT-OP = new PrimOp
public val BITS-SELECT-OP = new PrimOp
public val BIT-AND-REDUCE-OP = new PrimOp
public val BIT-OR-REDUCE-OP = new PrimOp
public val BIT-XOR-REDUCE-OP = new PrimOp

public definterface Expression
public defmulti type (e:Expression) -> Type

public defstruct Ref <: Expression :
   name: Symbol
   type: Type with: (as-method => true)
public defstruct SubField <: Expression :
   exp: Expression
   name: Symbol
   type: Type with: (as-method => true)
public defstruct SubIndex <: Expression :
   exp: Expression
   value: Int
   type: Type with: (as-method => true)
public defstruct SubAccess <: Expression :
   exp: Expression
   index: Expression
   type: Type with: (as-method => true)
public defstruct Mux <: Expression :
   cond: Expression
   tval: Expression
   fval: Expression
   type: Type with: (as-method => true)
public defstruct ValidIf <: Expression :
   cond: Expression
   value: Expression
   type: Type with: (as-method => true)
public defstruct UIntValue <: Expression :
   value: BigInt
   width: Width
public defstruct SIntValue <: Expression :
   value: BigInt
   width: Width
public defstruct DoPrim <: Expression :
   op: PrimOp
   args: List<Expression>
   consts: List<Int>
   type: Type with: (as-method => true)

public definterface Stmt
public defmulti info (s:Stmt) -> FileInfo

public defstruct DefWire <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   name: Symbol
   type: Type
public defstruct DefRegister <: Stmt :
   info: FileInfo with: (as-method => true)
   name: Symbol
   type: Type
   clock: Expression
   reset: Expression
   init: Expression
public defstruct DefInstance <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   name: Symbol
   module: Symbol
public defstruct DefMemory <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   name: Symbol
   data-type: Type
   depth: Int
   write-latency: Int
   read-latency: Int
   readers: List<Symbol>
   writers: List<Symbol>
   readwriters: List<Symbol>
public defstruct DefNode <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   name: Symbol
   value: Expression
public defstruct DefPoison <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   name: Symbol
   type: Type
public defstruct Conditionally <: Stmt :
   info: FileInfo with: (as-method => true)
   pred: Expression
   conseq: Stmt
   alt: Stmt
public defstruct Begin <: Stmt : ;LOW
   body: List<Stmt>
public defstruct BulkConnect <: Stmt : 
   info: FileInfo with: (as-method => true)
   loc: Expression
   exp: Expression
public defstruct Connect <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   loc: Expression
   exp: Expression
public defstruct IsInvalid <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   exp: Expression
public defstruct Stop <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   ret: Int
   clk: Expression
   en: Expression
public defstruct Print <: Stmt : ;LOW
   info: FileInfo with: (as-method => true)
   string: String
   args: List<Expression>
   clk: Expression
   en: Expression
public defstruct Empty <: Stmt ;LOW


public definterface Type
public defstruct UIntType <: Type :
   width: Width
public defstruct SIntType <: Type :
   width: Width
public defstruct BundleType <: Type :
   fields: List<Field>
public defstruct VectorType <: Type :
   type: Type
   size: Int
public defstruct ClockType <: Type
public defstruct UnknownType <: Type

public defstruct Field :
   name: Symbol
   flip: Flip
   type: Type

public defstruct Port :
   info: FileInfo
   name: Symbol
   direction: Direction
   type: Type

public definterface Module
public defmulti name (m:Module) -> Symbol
public defmulti ports (m:Module) -> List<Port>
public defmulti info (m:Module) -> FileInfo

public defstruct InModule <: Module :
   info: FileInfo with: (as-method => true)
   name: Symbol with: (as-method => true)
   ports: List<Port> with: (as-method => true)
   body: Stmt

public defstruct ExModule <: Module :
   info: FileInfo with: (as-method => true)
   name: Symbol with: (as-method => true)
   ports: List<Port> with: (as-method => true)

public defstruct Circuit :
   info: FileInfo
   modules: List<Module>
   main: Symbol
